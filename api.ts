// NOTE: GENERATED by github.com/mjl-/sherpats, DO NOT MODIFY

namespace api {

// Build is an attempt at building a repository.
export interface Build {
	ID: number
	RepoName: string
	Branch: string
	CommitHash: string  // Can be empty until `checkout` step, when building latest version of a branch.
	Status: BuildStatus
	Created: Date  // Time of creation of this build. Ding only has one concurrent build per repo, so the start time may be later.
	Start?: Date | null  // Time the build was started. Of a build is finish - start.
	Finish?: Date | null
	ErrorMessage: string
	Released?: Date | null  // Once set, this build itself won't be removed from the database, but its build directory may be removed.
	BuilddirRemoved: boolean
	Coverage?: number | null  // Test coverage in percentage, from 0 to 100.
	CoverageReportFile: string  // Relative to URL /dl/<reponame>/<buildid>.
	Version: string  // Version if this build, typically contains a semver version, with optional commit count/hash, perhaps a branch.
	BuildScript: string
	LowPrio: boolean  // Low-prio builds run after regular builds for a repo have finished. And we only run one low-prio build in ding at a time. Useful after a toolchain update.
	LastLine: string  // Last line of output, when build has completed.
	DiskUsage: number  // Disk usage for build.
	HomeDiskUsageDelta: number  // Change in disk usage of shared home directory, if enabled for this repository. Disk usage can shrink, e.g. after a cleanup.
	Results?: Result[] | null  // Only set for success builds.
	Steps?: Step[] | null  // Only set for finished builds.
}

// Result is a file created during a build, as the result of a build.
export interface Result {
	Command: string  // Short name of command, without version, as you would want to run it from a command-line.
	Os: string  // eg `any`, `linux`, `darwin, `openbsd`, `windows`.
	Arch: string  // eg `any`, `amd64`, `arm64`.
	Toolchain: string  // String describing the tools used during build, eg SDK version.
	Filename: string  // Path relative to the checkout directory where build.sh is run. For builds, the file is started at <dataDir>/build/<repoName>/<buildID>/checkout/<checkoutPath>/<filename>. For releases, the file is stored gzipped at <dataDir>/release/<repoName>/<buildID>/<basename of filename>.gz.
	Filesize: number  // Size of filename.
}

// Step is one phase of a build and stores the output generated in that step.
export interface Step {
	Name: string  // Mostly same values as build.status.
	Output: string  // Combined output of stdout and stderr.
	Nsec: number  // Time it took this step to finish, initially 0.
}

// RepoBuilds is a repository and its recent builds, per branch.
export interface RepoBuilds {
	Repo: Repo
	Builds?: Build[] | null  // Field Steps is cleared to reduce data transferred.
}

// Repo is a repository as stored in the database.
export interface Repo {
	Name: string  // Short name for repo, typically last element of repo URL/path.
	VCS: VCS
	Origin: string  // git/mercurial "URL" (as understood by the respective commands), often SSH or HTTPS. if `vcs` is `command`, this is executed using sh.
	DefaultBranch: string  // Name of default branch, e.g. "main" or "master" for git, or "default" for mercurial, empty for command.
	CheckoutPath: string  // Path to place the checkout in.
	BuildScript: string  // Shell scripts that compiles the software, runs tests, and creates releasable files.
	UID?: number | null  // If set, fixed uid to use for builds, sharing a home directory where files can be cached, to speed up builds.
	HomeDiskUsage: number  // Disk usage of shared home directory after last finished build. Only if UID is set.
}

// BuildStatus indicates the progress of a build.
export enum BuildStatus {
	StatusNew = "new",  // Build queued but not yet started.
	StatusClone = "clone",  // Cloning source code, e.g. from git.
	StatusBuild = "build",  // Building application.
	StatusSuccess = "success",  // Build was successful.
	StatusCancelled = "cancelled",  // Build was cancelled before finishing.
}

// VCS indicates the mechanism to fetch the source code.
export enum VCS {
	VCSGit = "git",
	VCSMercurial = "mercurial",
	// Custom shell script that will do the cloning. Escape hatch mechanism to support
	// past/future systems.
	VCSCommand = "command",
}

// EventRepo represents an update of a repository or creation of a repository.
export interface EventRepo {
	Repo: Repo
}

// EventRemoveRepo represents the removal of a repository.
export interface EventRemoveRepo {
	RepoName: string
}

// EventBuild represents an update to a build, or the start of a new build.
// Output is not part of the build, see EventOutput below.
export interface EventBuild {
	RepoName: string
	Build: Build
}

// EventRemoveBuild represents the removal of a build from the database.
export interface EventRemoveBuild {
	RepoName: string
	BuildID: number
}

// EventOutput represents new output from a build.
// Text only contains the newly added output, not the full output so far.
export interface EventOutput {
	BuildID: number
	Step: string  // During which the output was generated, eg `clone`, `build`.
	Where: string  // `stdout` or `stderr`.
	Text: string  // Lines of text written.
}

export const structTypes: {[typename: string]: boolean} = {"Build":true,"EventBuild":true,"EventOutput":true,"EventRemoveBuild":true,"EventRemoveRepo":true,"EventRepo":true,"Repo":true,"RepoBuilds":true,"Result":true,"Step":true}
export const stringsTypes: {[typename: string]: boolean} = {"BuildStatus":true,"VCS":true}
export const intsTypes: {[typename: string]: boolean} = {}
export const types: TypenameMap = {
	"Build": {"Name":"Build","Docs":"","Fields":[{"Name":"ID","Docs":"","Typewords":["int32"]},{"Name":"RepoName","Docs":"","Typewords":["string"]},{"Name":"Branch","Docs":"","Typewords":["string"]},{"Name":"CommitHash","Docs":"","Typewords":["string"]},{"Name":"Status","Docs":"","Typewords":["BuildStatus"]},{"Name":"Created","Docs":"","Typewords":["timestamp"]},{"Name":"Start","Docs":"","Typewords":["nullable","timestamp"]},{"Name":"Finish","Docs":"","Typewords":["nullable","timestamp"]},{"Name":"ErrorMessage","Docs":"","Typewords":["string"]},{"Name":"Released","Docs":"","Typewords":["nullable","timestamp"]},{"Name":"BuilddirRemoved","Docs":"","Typewords":["bool"]},{"Name":"Coverage","Docs":"","Typewords":["nullable","float32"]},{"Name":"CoverageReportFile","Docs":"","Typewords":["string"]},{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"BuildScript","Docs":"","Typewords":["string"]},{"Name":"LowPrio","Docs":"","Typewords":["bool"]},{"Name":"LastLine","Docs":"","Typewords":["string"]},{"Name":"DiskUsage","Docs":"","Typewords":["int64"]},{"Name":"HomeDiskUsageDelta","Docs":"","Typewords":["int64"]},{"Name":"Results","Docs":"","Typewords":["[]","Result"]},{"Name":"Steps","Docs":"","Typewords":["[]","Step"]}]},
	"Result": {"Name":"Result","Docs":"","Fields":[{"Name":"Command","Docs":"","Typewords":["string"]},{"Name":"Os","Docs":"","Typewords":["string"]},{"Name":"Arch","Docs":"","Typewords":["string"]},{"Name":"Toolchain","Docs":"","Typewords":["string"]},{"Name":"Filename","Docs":"","Typewords":["string"]},{"Name":"Filesize","Docs":"","Typewords":["int64"]}]},
	"Step": {"Name":"Step","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Output","Docs":"","Typewords":["string"]},{"Name":"Nsec","Docs":"","Typewords":["int64"]}]},
	"RepoBuilds": {"Name":"RepoBuilds","Docs":"","Fields":[{"Name":"Repo","Docs":"","Typewords":["Repo"]},{"Name":"Builds","Docs":"","Typewords":["[]","Build"]}]},
	"Repo": {"Name":"Repo","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"VCS","Docs":"","Typewords":["VCS"]},{"Name":"Origin","Docs":"","Typewords":["string"]},{"Name":"DefaultBranch","Docs":"","Typewords":["string"]},{"Name":"CheckoutPath","Docs":"","Typewords":["string"]},{"Name":"BuildScript","Docs":"","Typewords":["string"]},{"Name":"UID","Docs":"","Typewords":["nullable","uint32"]},{"Name":"HomeDiskUsage","Docs":"","Typewords":["int64"]}]},
	"BuildStatus": {"Name":"BuildStatus","Docs":"","Values":[{"Name":"StatusNew","Value":"new","Docs":""},{"Name":"StatusClone","Value":"clone","Docs":""},{"Name":"StatusBuild","Value":"build","Docs":""},{"Name":"StatusSuccess","Value":"success","Docs":""},{"Name":"StatusCancelled","Value":"cancelled","Docs":""}]},
	"VCS": {"Name":"VCS","Docs":"","Values":[{"Name":"VCSGit","Value":"git","Docs":""},{"Name":"VCSMercurial","Value":"mercurial","Docs":""},{"Name":"VCSCommand","Value":"command","Docs":""}]},
	"EventRepo": {"Name":"EventRepo","Docs":"EventRepo represents an update of a repository or creation of a repository.","Fields":[{"Name":"Repo","Docs":"","Typewords":["Repo"]}]},
	"EventRemoveRepo": {"Name":"EventRemoveRepo","Docs":"EventRemoveRepo represents the removal of a repository.","Fields":[{"Name":"RepoName","Docs":"","Typewords":["string"]}]},
	"EventBuild": {"Name":"EventBuild","Docs":"EventBuild represents an update to a build, or the start of a new build.\nOutput is not part of the build, see EventOutput below.","Fields":[{"Name":"RepoName","Docs":"","Typewords":["string"]},{"Name":"Build","Docs":"","Typewords":["Build"]}]},
	"EventRemoveBuild": {"Name":"EventRemoveBuild","Docs":"EventRemoveBuild represents the removal of a build from the database.","Fields":[{"Name":"RepoName","Docs":"","Typewords":["string"]},{"Name":"BuildID","Docs":"","Typewords":["int32"]}]},
	"EventOutput": {"Name":"EventOutput","Docs":"EventOutput represents new output from a build.\nText only contains the newly added output, not the full output so far.","Fields":[{"Name":"BuildID","Docs":"","Typewords":["int32"]},{"Name":"Step","Docs":"During which the output was generated, eg `clone`, `build`.","Typewords":["string"]},{"Name":"Where","Docs":"`stdout` or `stderr`.","Typewords":["string"]},{"Name":"Text","Docs":"Lines of text written.","Typewords":["string"]}]},
}

export const parser = {
	Build: (v: any) => parse("Build", v) as Build,
	Result: (v: any) => parse("Result", v) as Result,
	Step: (v: any) => parse("Step", v) as Step,
	RepoBuilds: (v: any) => parse("RepoBuilds", v) as RepoBuilds,
	Repo: (v: any) => parse("Repo", v) as Repo,
	BuildStatus: (v: any) => parse("BuildStatus", v) as BuildStatus,
	VCS: (v: any) => parse("VCS", v) as VCS,
	EventRepo: (v: any) => parse("EventRepo", v) as EventRepo,
	EventRemoveRepo: (v: any) => parse("EventRemoveRepo", v) as EventRemoveRepo,
	EventBuild: (v: any) => parse("EventBuild", v) as EventBuild,
	EventRemoveBuild: (v: any) => parse("EventRemoveBuild", v) as EventRemoveBuild,
	EventOutput: (v: any) => parse("EventOutput", v) as EventOutput,
}

// The Ding API lets you compile git branches, build binaries, run tests, and
// publish binaries.
//
// # Server-Sent Events
// SSE is a real-time streaming updates API using server-sent event, available at /events.
// Query string parameter "password" is required.
// You'll receive the following events with a HTTP GET request to `/events`, encoded as JSON:
// - `repo`, repository was updated or created
// - `removeRepo`, repository was removed
// - `build`, build was updated or created
// - `removeBuild`, build was removed
// - `output`, new lines of output from a command for an active build
// 
// These types are described below, with an _event_-prefix. E.g. type _EventRepo_ describes the `repo` event.
let defaultOptions: ClientOptions = {slicesNullable: true, mapsNullable: true, nullableOptional: true}

export class Client {
	private baseURL: string
	public authState: AuthState
	public options: ClientOptions

	constructor() {
		this.authState = {}
		this.options = {...defaultOptions}
		this.baseURL = this.options.baseURL || defaultBaseURL
	}

	withAuthToken(token: string): Client {
		const c = new Client()
		c.authState.token = token
		c.options = this.options
		return c
	}

	withOptions(options: ClientOptions): Client {
		const c = new Client()
		c.authState = this.authState
		c.options = { ...this.options, ...options }
		return c
	}

	// Status checks the health of the application.
	async Status(): Promise<void> {
		const fn: string = "Status"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = []
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// BuildCreate builds a specific commit in the background, returning immediately.
	// 
	// `Commit` can be empty, in which case the origin is cloned and the checked
	// out commit is looked up.
	// 
	// Low priority builds are executed after regular builds. And only one low
	// priority build is running over all repo's.
	async BuildCreate(password: string, repoName: string, branch: string, commit: string, lowPrio: boolean): Promise<Build> {
		const fn: string = "BuildCreate"
		const paramTypes: string[][] = [["string"],["string"],["string"],["string"],["bool"]]
		const returnTypes: string[][] = [["Build"]]
		const params: any[] = [password, repoName, branch, commit, lowPrio]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Build
	}

	// CreateBuild exists for compatibility with older "ding kick" behaviour.
	async CreateBuild(password: string, repoName: string, branch: string, commit: string): Promise<Build> {
		const fn: string = "CreateBuild"
		const paramTypes: string[][] = [["string"],["string"],["string"],["string"]]
		const returnTypes: string[][] = [["Build"]]
		const params: any[] = [password, repoName, branch, commit]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Build
	}

	// BuildsCreateLowPrio creates low priority builds for each repository, for the default branch.
	async BuildsCreateLowPrio(password: string): Promise<void> {
		const fn: string = "BuildsCreateLowPrio"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [password]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// BuildCancel cancels a currently running build.
	async BuildCancel(password: string, repoName: string, buildID: number): Promise<void> {
		const fn: string = "BuildCancel"
		const paramTypes: string[][] = [["string"],["string"],["int32"]]
		const returnTypes: string[][] = []
		const params: any[] = [password, repoName, buildID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// ReleaseCreate release a build.
	async ReleaseCreate(password: string, repoName: string, buildID: number): Promise<Build> {
		const fn: string = "ReleaseCreate"
		const paramTypes: string[][] = [["string"],["string"],["int32"]]
		const returnTypes: string[][] = [["Build"]]
		const params: any[] = [password, repoName, buildID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Build
	}

	// RepoBuilds returns all repositories and recent build info for "active" branches.
	// A branch is active if its name is "master" or "main" (for git), "default" (for hg), or
	// "develop", or if the last build was less than 4 weeks ago. The most recent
	// build is returned.
	async RepoBuilds(password: string): Promise<RepoBuilds[] | null> {
		const fn: string = "RepoBuilds"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["[]","RepoBuilds"]]
		const params: any[] = [password]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as RepoBuilds[] | null
	}

	// Repo returns the named repository.
	async Repo(password: string, repoName: string): Promise<Repo> {
		const fn: string = "Repo"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = [["Repo"]]
		const params: any[] = [password, repoName]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Repo
	}

	// Builds returns builds for a repo.
	// 
	// The Steps field of builds is cleared for transfer size.
	async Builds(password: string, repoName: string): Promise<Build[] | null> {
		const fn: string = "Builds"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = [["[]","Build"]]
		const params: any[] = [password, repoName]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Build[] | null
	}

	// RepoCreate creates a new repository.
	// If repo.UID is not null, a unique uid is assigned.
	async RepoCreate(password: string, repo: Repo): Promise<Repo> {
		const fn: string = "RepoCreate"
		const paramTypes: string[][] = [["string"],["Repo"]]
		const returnTypes: string[][] = [["Repo"]]
		const params: any[] = [password, repo]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Repo
	}

	// RepoSave changes a repository.
	async RepoSave(password: string, repo: Repo): Promise<Repo> {
		const fn: string = "RepoSave"
		const paramTypes: string[][] = [["string"],["Repo"]]
		const returnTypes: string[][] = [["Repo"]]
		const params: any[] = [password, repo]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Repo
	}

	// RepoClearHomedir removes the home directory this repository shares across
	// builds.
	async RepoClearHomedir(password: string, repoName: string): Promise<void> {
		const fn: string = "RepoClearHomedir"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [password, repoName]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// ClearRepoHomedirs removes the home directory of all repositories.
	async ClearRepoHomedirs(password: string): Promise<void> {
		const fn: string = "ClearRepoHomedirs"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [password]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// RepoRemove removes a repository and all its builds.
	async RepoRemove(password: string, repoName: string): Promise<void> {
		const fn: string = "RepoRemove"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [password, repoName]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// Build returns the build, including steps output.
	async Build(password: string, repoName: string, buildID: number): Promise<Build> {
		const fn: string = "Build"
		const paramTypes: string[][] = [["string"],["string"],["int32"]]
		const returnTypes: string[][] = [["Build"]]
		const params: any[] = [password, repoName, buildID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Build
	}

	// BuildRemove removes a build completely. Both from database and all local files.
	async BuildRemove(password: string, buildID: number): Promise<void> {
		const fn: string = "BuildRemove"
		const paramTypes: string[][] = [["string"],["int32"]]
		const returnTypes: string[][] = []
		const params: any[] = [password, buildID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// BuildCleanupBuilddir cleans up (removes) a build directory.
	// This does not remove the build itself from the database.
	async BuildCleanupBuilddir(password: string, repoName: string, buildID: number): Promise<Build> {
		const fn: string = "BuildCleanupBuilddir"
		const paramTypes: string[][] = [["string"],["string"],["int32"]]
		const returnTypes: string[][] = [["Build"]]
		const params: any[] = [password, repoName, buildID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Build
	}

	// GoToolchainsListInstalled returns the installed Go toolchains (eg "go1.13.8",
	// "go1.14") in GoToolchainDir, and current "active" versions with a shortname, eg
	// "go" as "go1.14" and "go-prev" as "go1.13.8".
	async GoToolchainsListInstalled(password: string): Promise<[string[] | null, { [key: string]: string }]> {
		const fn: string = "GoToolchainsListInstalled"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["[]","string"],["{}","string"]]
		const params: any[] = [password]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as [string[] | null, { [key: string]: string }]
	}

	// GoToolchainsListReleased returns all known released Go toolchains available at
	// golang.org/dl/, eg "go1.13.8", "go1.14".
	async GoToolchainsListReleased(password: string): Promise<string[] | null> {
		const fn: string = "GoToolchainsListReleased"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["[]","string"]]
		const params: any[] = [password]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as string[] | null
	}

	// GoToolchainInstall downloads, verifies and extracts the release Go toolchain
	// represented by goversion (eg "go1.13.8", "go1.14") into the GoToolchainDir, and
	// optionally "activates" the version under shortname ("go", "go-prev", ""; empty
	// string does nothing).
	async GoToolchainInstall(password: string, goversion: string, shortname: string): Promise<void> {
		const fn: string = "GoToolchainInstall"
		const paramTypes: string[][] = [["string"],["string"],["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [password, goversion, shortname]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// GoToolchainRemove removes a toolchain from go toolchain dir.
	// It does not remove a shortname symlink to this toolchain if it exists.
	async GoToolchainRemove(password: string, goversion: string): Promise<void> {
		const fn: string = "GoToolchainRemove"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [password, goversion]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// GoToolchainActivate activates goversion (eg "go1.13.8", "go1.14") under the name
	// shortname ("go" or "go-prev"), by creating a symlink in the GoToolchainDir.
	async GoToolchainActivate(password: string, goversion: string, shortname: string): Promise<void> {
		const fn: string = "GoToolchainActivate"
		const paramTypes: string[][] = [["string"],["string"],["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [password, goversion, shortname]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}
	// ExampleSSE is a no-op.
	// This function only serves to include documentation for the server-sent event types.
	async ExampleSSE(): Promise<[EventRepo, EventRemoveRepo, EventBuild, EventRemoveBuild, EventOutput]> {
		const fn: string = "ExampleSSE"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = [["EventRepo"],["EventRemoveRepo"],["EventBuild"],["EventRemoveBuild"],["EventOutput"]]
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as [EventRepo, EventRemoveRepo, EventBuild, EventRemoveBuild, EventOutput]
	}
}

export const defaultBaseURL = (function() {
	let p = location.pathname
	if (p && p[p.length - 1] !== '/') {
		let l = location.pathname.split('/')
		l = l.slice(0, l.length - 1)
		p = '/' + l.join('/') + '/'
	}
	return location.protocol + '//' + location.host + p + 'ding/'
})()

// NOTE: code below is shared between github.com/mjl-/sherpaweb and github.com/mjl-/sherpats.
// KEEP IN SYNC.

export const supportedSherpaVersion = 1

export interface Section {
	Name: string
	Docs: string
	Functions: Function[]
	Sections: Section[]
	Structs: Struct[]
	Ints: Ints[]
	Strings: Strings[]
	Version: string // only for top-level section
	SherpaVersion: number // only for top-level section
	SherpadocVersion: number // only for top-level section
}

export interface Function {
	Name: string
	Docs: string
	Params: Arg[]
	Returns: Arg[]
}

export interface Arg {
	Name: string
	Typewords: string[]
}

export interface Struct {
	Name: string
	Docs: string
	Fields: Field[]
}

export interface Field {
	Name: string
	Docs: string
	Typewords: string[]
}

export interface Ints {
	Name: string
	Docs: string
	Values: {
		Name: string
		Value: number
		Docs: string
	}[] | null
}

export interface Strings {
	Name: string
	Docs: string
	Values: {
		Name: string
		Value: string
		Docs: string
	}[] | null
}

export type NamedType = Struct | Strings | Ints
export type TypenameMap = { [k: string]: NamedType }

// verifyArg typechecks "v" against "typewords", returning a new (possibly modified) value for JSON-encoding.
// toJS indicate if the data is coming into JS. If so, timestamps are turned into JS Dates. Otherwise, JS Dates are turned into strings.
// allowUnknownKeys configures whether unknown keys in structs are allowed.
// types are the named types of the API.
export const verifyArg = (path: string, v: any, typewords: string[], toJS: boolean, allowUnknownKeys: boolean, types: TypenameMap, opts: ClientOptions): any => {
	return new verifier(types, toJS, allowUnknownKeys, opts).verify(path, v, typewords)
}

export const parse = (name: string, v: any): any => verifyArg(name, v, [name], true, false, types, defaultOptions)

class verifier {
	constructor(private types: TypenameMap, private toJS: boolean, private allowUnknownKeys: boolean, private opts: ClientOptions) {
	}

	verify(path: string, v: any, typewords: string[]): any {
		typewords = typewords.slice(0)
		const ww = typewords.shift()

		const error = (msg: string) => {
			if (path != '') {
				msg = path + ': ' + msg
			}
			throw new Error(msg)
		}

		if (typeof ww !== 'string') {
			error('bad typewords')
			return // should not be necessary, typescript doesn't see error always throws an exception?
		}
		const w: string = ww

		const ensure = (ok: boolean, expect: string): any => {
			if (!ok) {
				error('got ' + JSON.stringify(v) + ', expected ' + expect)
			}
			return v
		}

		switch (w) {
		case 'nullable':
			if (v === null || v === undefined && this.opts.nullableOptional) {
				return v
			}
			return this.verify(path, v, typewords)
		case '[]':
			if (v === null && this.opts.slicesNullable || v === undefined && this.opts.slicesNullable && this.opts.nullableOptional) {
				return v
			}
			ensure(Array.isArray(v), "array")
			return v.map((e: any, i: number) => this.verify(path + '[' + i + ']', e, typewords))
		case '{}':
			if (v === null && this.opts.mapsNullable || v === undefined && this.opts.mapsNullable && this.opts.nullableOptional) {
				return v
			}
			ensure(v !== null || typeof v === 'object', "object")
			const r: any = {}
			for (const k in v) {
				r[k] = this.verify(path + '.' + k, v[k], typewords)
			}
			return r
		}

		ensure(typewords.length == 0, "empty typewords")
		const t = typeof v
		switch (w) {
		case 'any':
			return v
		case 'bool':
			ensure(t === 'boolean', 'bool')
			return v
		case 'int8':
		case 'uint8':
		case 'int16':
		case 'uint16':
		case 'int32':
		case 'uint32':
		case 'int64':
		case 'uint64':
			ensure(t === 'number' && Number.isInteger(v), 'integer')
			return v
		case 'float32':
		case 'float64':
			ensure(t === 'number', 'float')
			return v
		case 'int64s':
		case 'uint64s':
			ensure(t === 'number' && Number.isInteger(v) || t === 'string', 'integer fitting in float without precision loss, or string')
			return '' + v
		case 'string':
			ensure(t === 'string', 'string')
			return v
		case 'timestamp':
			if (this.toJS) {
				ensure(t === 'string', 'string, with timestamp')
				const d = new Date(v)
				if (d instanceof Date && !isNaN(d.getTime())) {
					return d
				}
				error('invalid date ' + v)
			} else {
				ensure(t === 'object' && v !== null, 'non-null object')
				ensure(v.__proto__ === Date.prototype, 'Date')
				return v.toISOString()
			}
		}

		// We're left with named types.
		const nt = this.types[w]
		if (!nt) {
			error('unknown type ' + w)
		}
		if (v === null) {
			error('bad value ' + v + ' for named type ' + w)
		}

		if (structTypes[nt.Name]) {
			const t = nt as Struct
			if (typeof v !== 'object') {
				error('bad value ' + v + ' for struct ' + w)
			}

			const r: any = {}
			for (const f of t.Fields) {
				r[f.Name] = this.verify(path + '.' + f.Name, v[f.Name], f.Typewords)
			}
			// If going to JSON also verify no unknown fields are present.
			if (!this.allowUnknownKeys) {
				const known: { [key: string]: boolean } = {}
				for (const f of t.Fields) {
					known[f.Name] = true
				}
				Object.keys(v).forEach((k) => {
					if (!known[k]) {
						error('unknown key ' + k + ' for struct ' + w)
					}
				})
			}
			return r
		} else if (stringsTypes[nt.Name]) {
			const t = nt as Strings
			if (typeof v !== 'string') {
				error('mistyped value ' + v + ' for named strings ' + t.Name)
			}
			if (!t.Values || t.Values.length === 0) {
				return v
			}
			for (const sv of t.Values) {
				if (sv.Value === v) {
					return v
				}
			}
			error('unknown value ' + v + ' for named strings ' + t.Name)
		} else if (intsTypes[nt.Name]) {
			const t = nt as Ints
			if (typeof v !== 'number' || !Number.isInteger(v)) {
				error('mistyped value ' + v + ' for named ints ' + t.Name)
			}
			if (!t.Values || t.Values.length === 0) {
				return v
			}
			for (const sv of t.Values) {
				if (sv.Value === v) {
					return v
				}
			}
			error('unknown value ' + v + ' for named ints ' + t.Name)
		} else {
			throw new Error('unexpected named type ' + nt)
		}
	}
}


export interface ClientOptions {
	baseURL?: string
	aborter?: {abort?: () => void}
	timeoutMsec?: number
	skipParamCheck?: boolean
	skipReturnCheck?: boolean
	slicesNullable?: boolean
	mapsNullable?: boolean
	nullableOptional?: boolean
	csrfHeader?: string
	login?: (reason: string) => Promise<string>
}

export interface AuthState {
	token?: string // For csrf request header.
	loginPromise?: Promise<void> // To let multiple API calls wait for a single login attempt, not each opening a login popup.
}

const _sherpaCall = async (baseURL: string, authState: AuthState, options: ClientOptions, paramTypes: string[][], returnTypes: string[][], name: string, params: any[]): Promise<any> => {
	if (!options.skipParamCheck) {
		if (params.length !== paramTypes.length) {
			return Promise.reject({ message: 'wrong number of parameters in sherpa call, saw ' + params.length + ' != expected ' + paramTypes.length })
		}
		params = params.map((v: any, index: number) => verifyArg('params[' + index + ']', v, paramTypes[index], false, false, types, options))
	}
	const simulate = async (json: string) => {
		const config = JSON.parse(json || 'null') || {}
		const waitMinMsec = config.waitMinMsec || 0
		const waitMaxMsec = config.waitMaxMsec || 0
		const wait = Math.random() * (waitMaxMsec - waitMinMsec)
		const failRate = config.failRate || 0
		return new Promise<void>((resolve, reject) => {
			if (options.aborter) {
				options.aborter.abort = () => {
					reject({ message: 'call to ' + name + ' aborted by user', code: 'sherpa:aborted' })
					reject = resolve = () => { }
				}
			}
			setTimeout(() => {
				const r = Math.random()
				if (r < failRate) {
					reject({ message: 'injected failure on ' + name, code: 'server:injected' })
				} else {
					resolve()
				}
				reject = resolve = () => { }
			}, waitMinMsec + wait)
		})
	}
	// Only simulate when there is a debug string. Otherwise it would always interfere
	// with setting options.aborter.
	let json: string = ''
	try {
		json = window.localStorage.getItem('sherpats-debug') || ''
	} catch (err) {}
	if (json) {
		await simulate(json)
	}

	const fn = (resolve: (v: any) => void, reject: (v: any) => void) => {
		let resolve1 = (v: any) => {
			resolve(v)
			resolve1 = () => { }
			reject1 = () => { }
		}
		let reject1 = (v: { code: string, message: string }) => {
			if ((v.code === 'user:noAuth' || v.code === 'user:badAuth')  && options.login) {
				const login = options.login
				if (!authState.loginPromise) {
					authState.loginPromise = new Promise((aresolve, areject) => {
						login(v.code === 'user:badAuth' ? (v.message || '') : '')
						.then((token) => {
							authState.token = token
							authState.loginPromise = undefined
							aresolve()
						}, (err: any) => {
							authState.loginPromise = undefined
							areject(err)
						})
					})
				}
				authState.loginPromise
				.then(() => {
					fn(resolve, reject)
				}, (err: any) => {
					reject(err)
				})
				return
			}
			reject(v)
			resolve1 = () => { }
			reject1 = () => { }
		}

		const url = baseURL + name
		const req = new window.XMLHttpRequest()
		if (options.aborter) {
			options.aborter.abort = () => {
				req.abort()
				reject1({ code: 'sherpa:aborted', message: 'request aborted' })
			}
		}
		req.open('POST', url, true)
		if (options.csrfHeader && authState.token) {
			req.setRequestHeader(options.csrfHeader, authState.token)
		}
		if (options.timeoutMsec) {
			req.timeout = options.timeoutMsec
		}
		req.onload = () => {
			if (req.status !== 200) {
				if (req.status === 404) {
					reject1({ code: 'sherpa:badFunction', message: 'function does not exist' })
				} else {
					reject1({ code: 'sherpa:http', message: 'error calling function, HTTP status: ' + req.status })
				}
				return
			}

			let resp: any
			try {
				resp = JSON.parse(req.responseText)
			} catch (err) {
				reject1({ code: 'sherpa:badResponse', message: 'bad JSON from server' })
				return
			}
			if (resp && resp.error) {
				const err = resp.error
				reject1({ code: err.code, message: err.message })
				return
			} else if (!resp || !resp.hasOwnProperty('result')) {
				reject1({ code: 'sherpa:badResponse', message: "invalid sherpa response object, missing 'result'" })
				return
			}

			if (options.skipReturnCheck) {
				resolve1(resp.result)
				return
			}
			let result = resp.result
			try {
				if (returnTypes.length === 0) {
					if (result) {
						throw new Error('function ' + name + ' returned a value while prototype says it returns "void"')
					}
				} else if (returnTypes.length === 1) {
					result = verifyArg('result', result, returnTypes[0], true, true, types, options)
				} else {
					if (result.length != returnTypes.length) {
						throw new Error('wrong number of values returned by ' + name + ', saw ' + result.length + ' != expected ' + returnTypes.length)
					}
					result = result.map((v: any, index: number) => verifyArg('result[' + index + ']', v, returnTypes[index], true, true, types, options))
				}
			} catch (err) {
				let errmsg = 'bad types'
				if (err instanceof Error) {
					errmsg = err.message
				}
				reject1({ code: 'sherpa:badTypes', message: errmsg })
			}
			resolve1(result)
		}
		req.onerror = () => {
			reject1({ code: 'sherpa:connection', message: 'connection failed' })
		}
		req.ontimeout = () => {
			reject1({ code: 'sherpa:timeout', message: 'request timeout' })
		}
		req.setRequestHeader('Content-Type', 'application/json')
		try {
			req.send(JSON.stringify({ params: params }))
		} catch (err) {
			reject1({ code: 'sherpa:badData', message: 'cannot marshal to JSON' })
		}
	}
	return await new Promise(fn)
}

}
